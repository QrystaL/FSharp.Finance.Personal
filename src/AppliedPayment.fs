namespace FSharp.Finance.Personal

open CustomerPayments

/// functions for handling received payments and calculating interest and/or charges where necessary
module AppliedPayment =

     /// an actual payment made on a particular day, optionally with charges applied, with the net effect and payment status calculated
    [<Struct>]
    type AppliedPayment = {
        /// the day the payment is made, as an offset of days from the start date
        AppliedPaymentDay: int<OffsetDay>
        /// the amount of any scheduled payment due on the current day
        ScheduledPayment: int64<Cent> voption
        /// the amounts of any actual payments made on the current day
        ActualPayments: int64<Cent> array
        /// a payment generated by the system e.g. to calculate a settlement figure
        GeneratedPayment: int64<Cent> voption
        /// details of any charges incurred on the current day
        IncurredCharges: Charge array
        /// the net effect of any payments made on the current day
        NetEffect: int64<Cent>
        /// the payment status based on the payments made on the current day
        PaymentStatus: CustomerPaymentStatus
    }

    /// groups payments by day, applying actual payments, adding a payment status and optionally a late payment charge if underpaid
    let applyPayments asOfDay intendedPurpose (latePaymentGracePeriod: int<DurationDay>) (latePaymentCharge: Amount voption) actualPayments scheduledPayments =
        if Array.isEmpty scheduledPayments then [||] else

        let nonZero = Array.filter(fun cp -> CustomerPaymentDetails.total cp.PaymentDetails <> 0L<Cent>)

        let payments =
            [| scheduledPayments; nonZero actualPayments |]
            |> Array.concat
            |> Array.groupBy _.PaymentDay
            |> Array.map(fun (offsetDay, payments) ->
                let scheduledPayment' = payments |> Array.tryPick(_.PaymentDetails >> function ScheduledPayment sp -> Some sp | _ -> None) |> toValueOption
 
                let actualPayments' = payments |> Array.choose(_.PaymentDetails >> function ActualPayment (ap, _) -> Some ap | _ -> None)

                let generatedPayment' = payments |> Array.tryPick(_.PaymentDetails >> function GeneratedPayment gp -> Some gp | _ -> None) |> toValueOption

                let netEffect, paymentStatus =
                    match scheduledPayment', Array.sum actualPayments' with
                    | ValueNone, 0L<Cent> -> 0L<Cent>, NoneScheduled
                    | ValueNone, ap when ap < 0L<Cent> -> ap, Refunded
                    | ValueNone, ap -> ap, ExtraPayment
                    | ValueSome sp, ap when ap < sp && offsetDay <= asOfDay && (int offsetDay + int latePaymentGracePeriod) >= int asOfDay ->
                        match intendedPurpose with
                        | IntendedPurpose.Quote quoteType when offsetDay < asOfDay -> 0L<Cent>, PaymentDue
                        | IntendedPurpose.Quote quoteType when offsetDay = asOfDay -> 0L<Cent>, Generated quoteType
                        | _ -> sp, PaymentDue
                    | ValueSome sp, _ when offsetDay > asOfDay -> sp, NotYetDue
                    | ValueSome sp, 0L<Cent> when sp > 0L<Cent> -> 0L<Cent>, MissedPayment
                    | ValueSome sp, ap when ap < sp -> ap, Underpayment
                    | ValueSome sp, ap when ap > sp -> ap, Overpayment
                    | _, ap -> ap, PaymentMade

                let charges =
                    payments
                    |> Array.collect(_.PaymentDetails >> function ActualPayment (_, c) -> c | _ -> [||])
                    |> fun pcc ->
                        if latePaymentCharge.IsSome then
                            pcc |> Array.append(match paymentStatus with MissedPayment | Underpayment -> [| Charge.LatePayment latePaymentCharge.Value |] | _ -> [||])
                        else pcc

                { AppliedPaymentDay = offsetDay; ScheduledPayment = scheduledPayment'; ActualPayments = actualPayments'; GeneratedPayment = generatedPayment'; IncurredCharges = charges; NetEffect = netEffect; PaymentStatus = paymentStatus }
            )

        match intendedPurpose with
            | IntendedPurpose.Quote quoteType ->
                let existingPaymentDay = payments |> Array.tryFind(fun ap -> ap.AppliedPaymentDay = asOfDay)
                if existingPaymentDay.IsSome then
                    payments
                    |> Array.map(fun ap -> if ap.AppliedPaymentDay = asOfDay then { ap with GeneratedPayment = ValueSome 0L<Cent> } else ap)
                else
                    let newAppliedPayment = {
                        AppliedPaymentDay = asOfDay
                        ScheduledPayment = ValueNone
                        ActualPayments = [||]
                        GeneratedPayment = ValueSome 0L<Cent>
                        IncurredCharges = [||]
                        NetEffect = 0L<Cent>
                        PaymentStatus = Generated quoteType
                    }
                    payments
                    |> Array.append [| newAppliedPayment |]

            | IntendedPurpose.Statement ->
                payments
        |> Array.sortBy _.AppliedPaymentDay
