namespace FSharp.Finance.Personal

/// categorising the types of incoming payments based on whether they are scheduled, actual or generated
module CustomerPayments =

    open System

    /// the status of the payment, allowing for delays due to payment-provider processing times
    [<RequireQualifiedAccess; Struct>]
    type ActualPayment =
        /// the payment has been initiated but is not yet confirmed
        | Pending of PendingAmount: int64<Cent>
        /// the payment had been initiated but was not confirmed within the timeout
        | TimedOut of TimedOutAmount: int64<Cent>
        /// the payment has been confirmed
        | Confirmed of ConfirmedAmount: int64<Cent>
        /// the payment has been failed, with optional charges (e.g. due to insufficient-funds penalties)
        | Failed of FailedAmount: int64<Cent> * Charges: Charge array

    /// either an extra scheduled payment (e.g. for a restructured payment plan) or an actual payment made, optionally with charges
    [<Struct>]
    type CustomerPaymentDetails =
        /// the amount of any extra scheduled payment due on the current day
        | ScheduledPayment of ScheduledPayment: int64<Cent>
        /// the amounts of any actual payments made on the current day, with any charges incurred
        | ActualPayment of ActualPayment: ActualPayment
        /// the amounts of any generated payments made on the current day and their type
        | GeneratedPayment of GeneratedPayment: int64<Cent>
        with
            /// the total amount of the payment
            static member total = function
                | ScheduledPayment sp -> sp
                | ActualPayment (ActualPayment.Pending ap) -> ap
                | ActualPayment (ActualPayment.TimedOut _) -> 0L<Cent>
                | ActualPayment (ActualPayment.Confirmed ap) -> ap
                | ActualPayment (ActualPayment.Failed _) -> 0L<Cent>
                | GeneratedPayment gp -> gp

    /// a payment (either extra scheduled or actually paid) to be applied to a payment schedule
    [<Struct>]
    type CustomerPayment = {
        /// the day the payment is made, as an offset of days from the start date
        PaymentDay: int<OffsetDay>
        /// the details of the payment
        PaymentDetails: CustomerPaymentDetails
    }
 
    /// the status of a payment made by the customer
    [<Struct>]
    type CustomerPaymentStatus =
        /// no payment is required on the specified day
        | NoneScheduled
        /// a payment has been initiated but not yet confirmed
        | PaymentPending
        /// a scheduled payment was made in full and on time
        | PaymentMade
        /// no payment is due on the specified day because of earlier extra-/overpayments
        | NothingDue
        /// a scheduled payment was missed completely
        | MissedPayment
        /// a scheduled payment was made on time but not in the full amount
        | Underpayment
        /// a scheduled payment was made on time but exceeded the full amount
        | Overpayment
        /// a payment was made on a day when no payments were scheduled
        | ExtraPayment
        /// a refund was processed
        | Refunded
        /// a scheduled payment is in the future (seen from the as-of date)
        | NotYetDue
        /// a scheduled payment has not been made on time but is within the late-charge grace period
        | PaymentDue
        /// a payment generated by the system in e.g. a settlement quote
        | Generated of QuoteType
        /// no payment needed because the loan has already been settled
        | NoLongerRequired

    /// whether a payment plan is generated according to a regular schedule or is an irregular array of payments
    [<Struct>]
    type CustomerPaymentSchedule =
        /// a regular schedule based on a unit-period config with a specific number of payments with an auto-calculated amount
        | RegularSchedule of UnitPeriodConfig: UnitPeriod.Config * PaymentCount: int
        /// a regular schedule based on a unit-period config with a specific number of payments of a specified amount
        | RegularFixedSchedule of FixedUnitPeriodConfig: UnitPeriod.Config * FixedPaymentCount: int * PaymentAmount: int64<Cent>
        /// just a bunch of payments
        | IrregularSchedule of IrregularSchedule: CustomerPayment array

    [<RequireQualifiedAccess; Struct>]
    type PaymentCountCalculation =
        | Manual of Count: int
        | Automatic of InterestRate: Interest.Rate

    /// calculates an estimated number of payments required to pay off an amount given a specific unitPeriod and interest rate
    let calculateCount unitPeriodConfig (outstandingBalance: int64<Cent>) (payment: int64<Cent>) interestRate =
        let roughUnitPeriodLength = unitPeriodConfig |> UnitPeriod.Config.roughLength
        let initialCount = if payment = 0L<Cent> then 0m else decimal outstandingBalance / decimal payment |> Math.Ceiling
        let estimatedYears = (roughUnitPeriodLength * initialCount) / 365m
        let annualInterestRate = interestRate |> Interest.Rate.annual |> Percent.toDecimal
        (1m + (annualInterestRate * estimatedYears)) * initialCount |> Math.Ceiling |> int

    /// creates a payment plan for fully amortising an outstanding balance based on a payment amount, unit-period config and interest rate
    let createPaymentSchedule (payment: int64<Cent>) paymentCountCalculation unitPeriodConfig (outstandingBalance: int64<Cent>) originalStartDate =
        let count =
            match paymentCountCalculation with
            | PaymentCountCalculation.Manual count -> count
            | PaymentCountCalculation.Automatic interestRate -> calculateCount unitPeriodConfig outstandingBalance payment interestRate
        unitPeriodConfig
        |> UnitPeriod.generatePaymentSchedule count UnitPeriod.Direction.Forward
        |> Array.map(fun d -> { PaymentDay = d |> OffsetDay.fromDate originalStartDate ; PaymentDetails = ScheduledPayment payment })
