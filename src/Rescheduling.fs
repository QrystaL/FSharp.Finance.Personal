namespace FSharp.Finance.Personal

open CustomerPayments
open Quotes

/// functions for rescheduling payments after an original schedule failed to amortise
module Rescheduling =

    /// the parameters used for setting up a payment plan
    [<RequireQualifiedAccess; Struct>]
    type RescheduleParameters = {
        /// whether the plan is autogenerated or a manual plan provided
        PaymentSchedule: CustomerPaymentSchedule
        /// any periods during which interest is not payable
        InterestHolidays: Holiday array
        /// any period during which charges are not payable
        ChargesHolidays: Holiday array
    }

    /// take an existing schedule and settle it, then use the result to create a new schedule to pay it off under different terms
    let reschedule sp (rp: RescheduleParameters) (actualPayments: CustomerPayment array) =
        voption {
            // fees will be carried over to the new schedule so should not be pro-rated
            let sp = { sp with PaymentSchedule.Parameters.FeesAndCharges.FeesSettlement = Fees.Settlement.DueInFull }
            // get the settlement quote
            let! quote = getQuote Settlement sp DoNotApplyNegativeInterest actualPayments
            // process the quote and extract the portions if applicable
            let! principalPortion, feesPortion =
                match quote.QuoteResult with
                | PaymentQuote (paymentQuote, ofWhichPrincipal, ofWhichFees, ofWhichInterest, ofWhichCharges) -> ValueSome (ofWhichPrincipal + ofWhichInterest + ofWhichCharges, ofWhichFees)
                | AwaitPaymentConfirmation -> ValueNone
                | UnableToGenerateQuote -> ValueNone
            // create a new payment schedule either by auto-generating it or using manual payments
            let newPaymentSchedule =
                match rp.PaymentSchedule with
                | RegularSchedule (unitPeriodConfig, paymentCount) ->
                    let schedule = PaymentSchedule.calculate BelowZero sp
                    match schedule with
                    | ValueSome s ->
                        s.Items
                        |> Array.filter(fun si -> si.Payment.IsSome)
                        |> Array.map(fun si -> { PaymentDay = si.Day; PaymentDetails = ScheduledPayment si.Payment.Value })
                    | ValueNone ->
                        [||]
                | RegularFixedSchedule (unitPeriodConfig, paymentCount, paymentAmount) ->
                    UnitPeriod.generatePaymentSchedule paymentCount UnitPeriod.Direction.Forward unitPeriodConfig
                    |> Array.map(fun d -> { PaymentDay = OffsetDay.fromDate sp.StartDate d; PaymentDetails = ScheduledPayment paymentAmount })
                | IrregularSchedule payments ->
                    payments
            // append the new schedule to the old schedule up to the point of settlement
            let oldPaymentSchedule =
                quote.RevisedSchedule.ScheduleItems
                |> Array.filter _.ScheduledPayment.IsSome
                |> Array.map(fun si -> { PaymentDay = si.OffsetDay; PaymentDetails = ScheduledPayment si.ScheduledPayment.Value })
            // configure the parameters for the new schedule
            let spNew =
                { sp with
                    PaymentSchedule = [| oldPaymentSchedule; newPaymentSchedule |] |> Array.concat |> IrregularSchedule
                    FeesAndCharges = { sp.FeesAndCharges with ChargesHolidays = rp.ChargesHolidays }
                    Interest = { sp.Interest with InitialGracePeriod = 0<DurationDay>; Holidays = rp.InterestHolidays }
                }
            // create the new amortiation schedule
            let! rescheduledSchedule = Amortisation.generate spNew IntendedPurpose.Statement DoNotApplyNegativeInterest (ValueSome quote.OriginalFinalPaymentDay) [||]
            return quote.RevisedSchedule, rescheduledSchedule
        }

    [<Struct>]
    type RolloverOptions =
        | DoNotRollOverFees
        | RollOverFees

    /// parameters for creating a rolled-over schedule
    [<Struct>]
    type RolloverParameters = {
        /// the scheduled payments or the parameters for generating them
        PaymentSchedule: CustomerPaymentSchedule
        /// options relating to fees
        FeesAndCharges: FeesAndCharges voption
        /// options relating to interest
        Interest: Interest.Options voption
        /// technical calculation options
        Calculation: PaymentSchedule.Calculation voption
        /// options affecting rollovers
        RolloverOptions: RolloverOptions
    }

    /// take an existing schedule and settle it, then use the result to create a new schedule to pay it off under different terms
    let rollOver sp rp (actualPayments: CustomerPayment array) =
        voption {
            // fees will be carried over to the new schedule so should not be pro-rated
            let sp = { sp with PaymentSchedule.Parameters.FeesAndCharges.FeesSettlement = Fees.Settlement.DueInFull }
            // get the settlement quote
            let! quote = getQuote Settlement sp DoNotApplyNegativeInterest actualPayments
            // process the quote and extract the portions if applicable
            let! principalPortion, feesPortion =
                match quote.QuoteResult with
                | PaymentQuote (paymentQuote, ofWhichPrincipal, ofWhichFees, ofWhichInterest, ofWhichCharges) ->
                    match rp.RolloverOptions with
                    | DoNotRollOverFees -> ofWhichPrincipal + ofWhichFees + ofWhichInterest + ofWhichCharges, 0L<Cent>
                    | RollOverFees -> ofWhichPrincipal + ofWhichInterest + ofWhichCharges, ofWhichFees
                    |> ValueSome
                | AwaitPaymentConfirmation -> ValueNone
                | UnableToGenerateQuote -> ValueNone
            // configure the parameters for the new schedule
            let spNew : PaymentSchedule.Parameters =
                {
                    AsOfDate = sp.AsOfDate
                    StartDate = sp.AsOfDate
                    Principal = principalPortion
                    PaymentSchedule = rp.PaymentSchedule
                    FeesAndCharges =
                        match rp.RolloverOptions with
                        | DoNotRollOverFees -> { sp.FeesAndCharges with Fees = [||] }
                        | RollOverFees -> { sp.FeesAndCharges with Fees = [| Fee.CustomFee ("Rolled-Over Fee", Amount.Simple feesPortion) |] }
                    Interest = rp.Interest |> ValueOption.defaultValue sp.Interest
                    Calculation = rp.Calculation |> ValueOption.defaultValue sp.Calculation
                }
            // create the new amortiation schedule
            let! rescheduledSchedule = Amortisation.generate spNew IntendedPurpose.Statement DoNotApplyNegativeInterest (ValueSome quote.OriginalFinalPaymentDay) [||]
            return quote.RevisedSchedule, rescheduledSchedule
        }

    /// to-do: create a function to disapply all interest paid so far
    let disapplyInterest =
        ()